<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeviCode</title>
  
  <subtitle>You can choose who you are.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.levicode.cn/"/>
  <updated>2018-07-14T03:40:21.482Z</updated>
  <id>http://blog.levicode.cn/</id>
  
  <author>
    <name>Levi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中单例模式的几种实现</title>
    <link href="http://blog.levicode.cn/2018/06/03/java-singleton-implements/"/>
    <id>http://blog.levicode.cn/2018/06/03/java-singleton-implements/</id>
    <published>2018-06-03T14:43:33.000Z</published>
    <updated>2018-07-14T03:40:21.482Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中单例模式有几种实现，在不同的使用场景下可以选择适当的实现。下面就让我们来看下具体的实现和各自的优缺点。</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line">        System.out.println(&quot;HungrySingleton is created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final HungrySingleton HUNGRY_SINGLETON = new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    public static HungrySingleton getInstance() &#123;</span><br><span class="line">        return HUNGRY_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式中实例被 <em>static</em> 和 <em>final</em> 修饰，在类加载到内存中时就会被初始化，不存在线程安全问题。<br>缺点是无法实现延迟加载，同时在实例构造时需要依赖参数或配置文件的场景下也无法使用。</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">        System.out.println(&quot;LazySingleton is created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static LazySingleton lazySingleton;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        if (lazySingleton == null) &#123;</span><br><span class="line">            lazySingleton = new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们再来看一下懒汉模式，这种方式虽然实现了延迟加载，但是在多线程场景下无法使用，原因是在多线程情况下当多个线程同时进入 <em>lazySingleton == null</em> 判断分支中，就会创建多个实例。</p><h2 id="双重检查模式"><a href="#双重检查模式" class="headerlink" title="双重检查模式"></a>双重检查模式</h2><p>在懒汉模式的基础上，我们自然而然会想到使用加锁的方式控制多个线程进入判断中，但是单例模式是一种“一次写多次读”的场景，如果在 <em>if</em> 判断前直接加锁，将会严重降低单例获取的性能.<br>因此，双重检查模式使用了一次前置判断，当实例不存在时才进行加锁操作，同时在加锁的同步代码块中也进行了一次判断，防止多个实例进入锁等待后创建多个实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleCheckSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private DoubleCheckSingleton() &#123;</span><br><span class="line">        System.out.println(&quot;DoubleCheckSingleton is created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static DoubleCheckSingleton doubleCheckSingleton;</span><br><span class="line"></span><br><span class="line">    public static DoubleCheckSingleton getInstance() &#123;</span><br><span class="line">        if (doubleCheckSingleton == null) &#123;</span><br><span class="line">            synchronized (DoubleCheckSingleton.class) &#123;</span><br><span class="line">                if (doubleCheckSingleton == null) &#123;</span><br><span class="line">                    doubleCheckSingleton = new DoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return doubleCheckSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实现会有什么问题吗？如果你够细心的话你就会发现 <em>doubleCheckSingleton = new DoubleCheckSingleton()</em> 这个操作是一个非原子操作，在JVM中把这句代码分了3步：</p><ol><li>为 <em>doubleCheckSingleton</em> 分配内存空间</li><li>执行 <em>DoubleCheckSingleton</em> 的构造函数进行初始化操作</li><li>将 <em>doubleCheckSingleton</em> 指向分配的内存空间（这步执行完后 <em>doubleCheckSingleton</em> 才不为<em>null</em> ）</li></ol><p>由于JVM即时编译器会进行指令重排，因此最后的执行顺序可能是 <em>1-2-3</em> 或 <em>1-3-2</em> ，当执行顺序是 <em>1-3-2</em> ，如果线程一执行完3后还未执行2，此时有线程二抢占CPU，拿到不为 <em>null</em> 的 <em>doubleCheckSingleton</em> 实例进行使用，但是实例并未被初始化，因此使用报错。<br>为了解决这个问题，像 <em><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="noopener">The “Double-Checked Locking is Broken” Declaration</a></em> 中提到的，我们需要使用 <em>volatile</em> 修饰实例变量 <em>doubleCheckSingleton</em> ，这样就可以禁止JVM即时编译器对 <em>doubleCheckSingleton</em> 实例对象的操作进行执行重排。需要注意 <em>volatile</em> 的这种使用只在 <em>JDK1.5</em> 及以上有效。让我们看一下最终的双重检查模式实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleCheckSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private DoubleCheckSingleton() &#123;</span><br><span class="line">        System.out.println(&quot;DoubleCheckSingleton is created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile static DoubleCheckSingleton doubleCheckSingleton;</span><br><span class="line"></span><br><span class="line">    public static DoubleCheckSingleton getInstance() &#123;</span><br><span class="line">        if (doubleCheckSingleton == null) &#123;</span><br><span class="line">            synchronized (DoubleCheckSingleton.class) &#123;</span><br><span class="line">                if (doubleCheckSingleton == null) &#123;</span><br><span class="line">                    doubleCheckSingleton = new DoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return doubleCheckSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class InnerClassSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private InnerClassSingleton() &#123;</span><br><span class="line">        System.out.println(&quot;InnerClassSingleton is created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final InnerClassSingleton INSTANCE = new InnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static InnerClassSingleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有的静态内部类保证了只有 <em>getInstance()</em> 才能访问到实例，并由JVM保证了创建实例时的线程安全问题，同时获取实例的时候不需要进行加锁同步操作，也不依赖JDK版本。这是《<em>Effective Java</em>》第一版中推荐的写法。</p><h2 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public enum  EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    EnumSingleton() &#123;</span><br><span class="line">        System.out.println(&quot;EnumSingleton is created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EnumSingleton enumSingleton1 = EnumSingleton.INSTANCE;</span><br><span class="line">        EnumSingleton enumSingleton2 = EnumSingleton.INSTANCE;</span><br><span class="line">        System.out.println(&quot;equals: &quot; + (enumSingleton1 == enumSingleton2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举实例的创建是线程安全的，枚举实例获取也不需要加锁同步，同时还防止了其他版本的单例实现中可以通过反射调用单例的私有构造方法，但是枚举中的其他方法的线程安全需要实现方自己负责。这是《<em>Effective Java</em>》第二版中推荐的写法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上主要介绍了Java中单例的5种实现方式，分别是饿汉模式、懒汉模式、双重检查模式、静态内部类模式、枚举模式，实际使用中还是要考虑使用的场景，是否需要延迟加载、是否需要序列化等。</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul><li><a href="https://coolshell.cn/articles/265.html" target="_blank" rel="noopener">深入浅出单实例SINGLETON设计模式</a></li><li><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="noopener">The “Double-Checked Locking is Broken” Declaration</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Java中单例模式有几种实现，在不同的使用场景下可以选择适当的实现。下面就让我们来看下具体的实现和各自的优缺点。&lt;/p&gt;
&lt;h2 id=&quot;饿汉模式&quot;&gt;&lt;a href=&quot;#饿汉模式&quot; class=&quot;headerlink&quot; title=&quot;饿汉模式&quot;&gt;&lt;/a&gt;饿汉模式&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
